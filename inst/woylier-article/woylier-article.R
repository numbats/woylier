# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit woylier-article.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tourr)
library(tidyverse)
library(woylier)
library(geozoo)
library(ggplot2)
library(patchwork)
library(gganimate)
library(GGally)
library(corrplot)


## ----splines2d-static, echo = FALSE, fig.height = 3, fig.cap="The plot on the right-hand side is a 30-degree rotation of the left-hand side. The calculated splines index is shown on top of each plot. Although they depict the same points we can see that the splines index is different which shows the rotational variance of the splines index.", fig.alt = "Two side-by-side scatterplots with 6 points. The plot on the right-hand side is a 30-degree rotation of the left-hand side. The calculated splines index is shown on top of each plot. Although they depict the same points we can see that the splines index is different which shows the rotational variance of the splines index."----
data("sine_curve")
mat <- data.frame(sine_curve[,5:6])
mat_idx <- round(tourr::splines2d()(mat), 2)
mat_rot <- data.frame(x = cos(pi/6) * sine_curve$V5 + 
                          sin(pi/6) * sine_curve$V6,
                      y = -sin(pi/6) * sine_curve$V5 + 
                           cos(pi/6) * sine_curve$V6)
mat_rot_idx <- round(tourr::splines2d()(mat_rot), 2)
p1 <- ggplot(mat, aes(x=V5, y=V6)) + 
  geom_point() + 
  ggtitle(paste("Splines index = ", mat_idx)) +
  theme(aspect.ratio=1)+
  theme_bw()
p2 <- ggplot(mat_rot, aes(x=x, y=y)) + 
  geom_point() + 
  xlab("Rotated 1") + ylab("Rotated 2") +
  ggtitle(paste("Splines index = ", mat_rot_idx)) +
  theme(aspect.ratio=1)+
  theme_bw()
p1+p2


## ----dogs, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', fig.cap="Plane to plane interpolation (left) and Frame to frame interpolation (right). We used dog index for illustration purposes. For some non-linear index orientation of data could affect the index."----
knitr::include_graphics(
  c("plane.png",
    "frame.png"))


## ----echo=TRUE----------------------------------------------------------------
set.seed(2022)
p <- 6
base1 <- tourr::basis_random(p, d=2)
base2 <- tourr::basis_random(p, d=2)

base1
base2


## ----echo=TRUE----------------------------------------------------------------
givens_full_path(base1, base2, nsteps = 5)


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> set.seed(2022)
#> p <- 6
#> base1 <- tourr::basis_random(p, d=1)
#> base2 <- tourr::basis_random(p, d=1)
#> 
#> frames <- givens_full_path(base1, base2, nsteps = 10)
#> 
#> sp <- generate_space_view(p=p)
#> 
#> sp_path <- add_path(sp, frames)
#> 
#> point1 <- as.data.frame(t(base1))
#> point1$type <- "point1"
#> 
#> point2 <- as.data.frame(t(base2))
#> point2$type <- "point2"
#> 
#> sp_path <- rbind(sp_path, point1, point2)
#> 
#> tourr::render_gif(sp_path[,1:p],
#>                   tour_path = grand_tour(),
#>                   display = display_xy(axes="bottomleft", col=sp_path$type),
#>                   frames = 100,
#>                   "sphere.gif")


## ----1d-path-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 1D projections of 6D data", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "2 highlighted points on the surface of sphere connected by 10 interpolated steps, rotating."----
#> knitr::include_graphics("sphere.gif")


## ----1d-path-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 1D projections of 6D data", include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.alt = "2 highlighted points on the surface of sphere connected by 10 interpolated steps, rotating."----
knitr::include_graphics("sphere_static.png")


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> set.seed(2022)
#> p <- 6
#> n <- 1500
#> d <- 2
#> base1 <- tourr::basis_random(p, d=2)
#> base2 <- tourr::basis_random(p, d=2)
#> frames_2d <- givens_full_path(base1, base2, 10)
#> proj_2d <- map(1:n, ~basis_random(n = p,  d=d)) %>%
#>   purrr::flatten_dbl() %>%
#>   matrix(ncol = p*2, byrow = TRUE) %>%
#>   as_tibble()
#> path_2d <- t(apply(frames_2d, 3, c)) %>%
#>   as.data.frame()
#> proj_2d <- proj_2d %>%
#>   mutate(type="torus")
#> path_2d <- path_2d %>%
#>   mutate(type="path")
#> proj_path <- bind_rows(proj_2d, path_2d)
#> 
#> tourr::render_gif(proj_path[,1:6],
#>                   tour_path = grand_tour(),
#>                   display = display_xy(axes="bottomleft", col=proj_path$type),
#>                   frames = 100,
#>                   "torus.gif")


## ----2d-path-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 2D projections of 6D data", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "2 highlighted points on the surface of torus connected by 10 interpolated steps, rotating."----
#> 
#> knitr::include_graphics("torus.gif")


## ----2d-path-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 2D projections of 6D data", include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.alt = "2 highlighted points on the surface of torus connected by 10 interpolated steps, rotating."----

knitr::include_graphics("torus_static.png")


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> # Generate a sample interpolation
#> set.seed(5543)
#> base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
#> base2 <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1), ncol=2, byrow=T)
#> sine_path <- givens_full_path(base1, base2, nsteps=100)
#> sine_all <- NULL
#> sine_proj <- NULL
#> for (i in 1:dim(sine_path)[3]) {
#>   d <- as.matrix(sine_curve) %*% as.matrix(sine_path[,,i])
#>   d <- data.frame(d)
#>   d$idx <- round(tourr::splines2d()(d), 2)
#>   d$frame <- i
#>   sine_all <- bind_rows(sine_all, d)
#>   prj <- as.data.frame(sine_path[,,i])
#>   prj$frame <- i
#>   prj$names <- colnames(sine_curve)
#>   sine_proj <- bind_rows(sine_proj, prj)
#> }
#> sine_label <- sine_all %>%
#>   mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
#> sine_proj <- sine_proj %>%
#>   mutate(cx = 0, cy = 0)
#> # With gganimate
#> 
#> sine_anim <- ggplot() +
#>   geom_segment(data=sine_proj, aes(x=V1, y=V2,
#>                                    xend=cx, yend=cy,
#>                                    group=frame),
#>                colour="grey60") +
#>   geom_text(data=sine_proj, aes(x=V1, y=V2,
#>                                 label=names,
#>                                 group=frame),
#>                colour="grey60") +
#>   geom_point(data=sine_label, aes(x=X1, y=X2)) +
#>   geom_text(data=sine_label, aes(x=labelX, y=labelY,
#>                 label=label_idx), size=10) +
#>   xlab("") + ylab("") +
#>   transition_time(frame) +
#>   theme_void() +
#>   theme(aspect.ratio=1,
#>         plot.background = element_rect(fill=NULL, colour = "black"))
#> 
#> animate(sine_anim, fps=8, renderer = gifski_renderer(loop = TRUE), width=400, height=400)
#> anim_save("sine_anim_givens.gif")


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> library(tourr)
#> set.seed(5541)
#> base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
#> base2 <- matrix(c(0,0,0,0,0,0,0,0,1, 0, 0, 1), ncol = 2, byrow = TRUE)
#> basis_set <- array(dim = c(6,2,2))
#> basis_set[,,1] <- base1
#> basis_set[,,2] <- base2
#> attr(basis_set, "class") <- c("history_array", class(basis_set))
#> path_geo <- tourr::interpolate(basis_set, angle = 0.0151)
#> data("sine_curve")
#> 
#> sine_all <- NULL
#> sine_proj <- NULL
#> for (i in 1:dim(path_geo)[3]) {
#>   d <- as.matrix(sine_curve) %*% matrix(c(path_geo[,,i][[1]]), ncol = 2)
#>   d <- data.frame(d)
#>   d$idx <- round(tourr::splines2d()(d), 2)
#>   d$frame <- i
#>   sine_all <- bind_rows(sine_all, d)
#>   prj <- as.data.frame(matrix(c(path_geo[,,i][[1]]), ncol = 2))
#>   prj$frame <- i
#>   prj$names <- colnames(sine_curve)
#>   sine_proj <- bind_rows(sine_proj, prj)
#> }
#> sine_label <- sine_all %>%
#>   mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
#> sine_proj <- sine_proj %>%
#>   mutate(cx = 0, cy = 0)
#> 
#> # With gganimate
#> sine_anim <- ggplot() +
#>   geom_segment(data=sine_proj, aes(x=V1, y=V2,
#>                                    xend=cx, yend=cy,
#>                                    group=frame),
#>                colour="grey60") +
#>   geom_text(data=sine_proj, aes(x=V1, y=V2,
#>                                 label=names,
#>                                 group=frame),
#>                colour="grey60") +
#>   geom_point(data=sine_label, aes(x=X1, y=X2)) +
#>   geom_text(data=sine_label, aes(x=labelX, y=labelY,
#>                 label=label_idx), size=10) +
#>   xlab("") + ylab("") +
#>   transition_time(frame) +
#>   theme_void() +
#>   theme(aspect.ratio=1,
#>         plot.background = element_rect(fill=NULL, colour = "black"))
#> 
#> animate(sine_anim, fps=8, renderer = gifski_renderer(loop = TRUE), width=400, height=400)
#> anim_save("sine_anim_geodesic.gif")


## ----compare-interpolations, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.cap="Givens interpolation path (left) and Geodesic interpolation path (right) to target frame. Givens interpolation goes to exact frame that has the correct orientation while Geodesic interpolation goes to rotation of the target plane."----
#> knitr::include_graphics(
#>   c("sine_anim_givens.gif",
#>     "sine_anim_geodesic.gif"))


## ----compare-interpolations-static, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.cap="Givens interpolation path (left) and Geodesic interpolation path (right) to target frame. Givens interpolation goes to exact frame that has the correct orientation while Geodesic interpolation goes to rotation of the target plane."----
knitr::include_graphics(
  c("given_sine.png",
    "geodesic_sine.png"))


## ----currency, fig.height = 5, fig.cap="All the currencies are standardised and the sign is flipped. The high value means the currency strengthened against the USD, and low means that it weakened."----
rates <- read_csv("rates_Nov19_Mar20.csv", show_col_types = FALSE) %>% 
  select(date, ARS, AUD, EUR, JPY, KRW, MYR) 
rates_sub <- rates %>%
  mutate_if(is.numeric, function(x) -1*(x-mean(x))/sd(x))
rates_sub_long <- rates_sub %>% 
  pivot_longer(cols=ARS:MYR, 
               names_to="currency",
               values_to="crossrate") 
ggplot(rates_sub_long, aes(x=date, y=crossrate, colour=currency)) + geom_line() +
  scale_colour_viridis_d("")+
  theme_bw()


## ----currency-corr, fig.height = 5, fig.cap="After standardisation, these currencies are still highly correlated with each other."----
corr <- cor(rates[2:7])
corrplot(corr, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)


## ----pca-result, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', eval=knitr::is_latex_output(), fig.cap="There is a strong non-linear dependence between PC1 and PC2."----
# Use PCA to remove linear dependence
rates_pca <- prcomp(rates[,-1], scale. = TRUE)
pca <- ggscatmat(rates_pca$x)
pca


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> # modified the splines2d
#> new_splines2d <- function ()
#> {
#>   function(mat) {
#>     mat <- as.data.frame(mat)
#>     colnames(mat) <- c("x", "y")
#>     kx <- ifelse(length(unique(mat$x[!is.na(mat$x)])) < 20,
#>                  3, 10)
#>     mgam1 <- mgcv::gam(y ~ s(x, bs = "cr", k = kx), data = mat)
#>     measure <- 1 - var(residuals(mgam1), na.rm = T)/var(mat$y, na.rm = T)
#>     return(measure)
#>   }
#> }
#> 
#> set.seed(202212)
#> basis2 <- basis_random(n=4, d = 2)
#> anim_geo <- save_history(rates_pca_sd[,1:4], tour_path = guided_tour(new_splines2d(), current = basis2))
#> 
#> anim_givens <- save_history(rates_pca_sd[,1:4], tour_path = guided_tour_givens(new_splines2d(), current = basis2, search_f = search_better, max.tries = 1000))
#> 
#> anim_givens_random <- save_history(rates_pca_sd[,1:4], tour_path = guided_tour_givens(new_splines2d(), current = basis2, search_f = search_better_random, max.tries = 1000))
#> 
#> render_gif(rates_pca_sd[,1:4], planned_tour(anim_geo), display = display_xy(), gif_file = "guided_geo.gif", loop = FALSE)
#> render_gif(rates_pca_sd[,1:4], planned_tour(anim_givens), display = display_xy(), gif_file = "guided_givens.gif", loop = FALSE)
#> render_gif(rates_pca_sd[,1:4], planned_tour(anim_givens_random), display = display_xy(), gif_file = "guided_givens_random.gif", loop = FALSE)


## ----guided-geo-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using geodesic interpolation.", include=knitr::is_html_output(), eval=knitr::is_html_output()----
#> knitr::include_graphics("guided_geo.gif")


## ----guided-geo-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using geodesic interpolation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()----
knitr::include_graphics("guided_geo.png")


## ----guided-givens-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using Givens interpolation.", include=knitr::is_html_output(), eval=knitr::is_html_output()----
#> knitr::include_graphics("guided_givens.gif")


## ----guided-givens-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using Givens interpolation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()----
knitr::include_graphics("guided_givens.png")


## ----guided-givens-random-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using Givens interpolation with search_better_random.", include=knitr::is_html_output(), eval=knitr::is_html_output()----
#> knitr::include_graphics("guided_givens_random.gif")


## ----guided-givens-random-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using Givens interpolation with search_better_random.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()----
knitr::include_graphics("guided_givens_random.png")

