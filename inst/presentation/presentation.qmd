---
title: "Woylier package:"
subtitle: "Alternative tour frame interpolation method"
author: "Zola Batsaikhan<br>Joint work with Professor Di Cook and Ursula Laa<br>October 17, 2022"
format: 
  revealjs:
    revealjs: 
    scrollable: true
    show-slide-number: all
    slide-number: true
    aspectratio: 169
    chalkboard: 
      buttons: true
    theme: styles.scss
    footer: <https://numbats.github.io/woylier/>
    title-block-banner: true
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tourr)
library(tidyverse)
library(woylier)
library(geozoo)
library(ggplot2)
library(patchwork)
library(emo)
```

## Woylier `r emo::ji("mouse_face")` {.scrollable transition="slide"}

-   Building an R package
-   Supervisor: Di Cook

::: {.notes}
Speaker notes go here.
:::

## Outline `r emo::ji("book")` {.scrollable transition="slide"}

-   Motivation of the project
-   Methodology
-   Implementation
-   Data application
-   Conclusion and next steps
-   Acknowledgements and references

## Motivation of the project `r emo::ji("dizzy")` {.smaller .scrollable transition="slide"}

::: panel-tabset
### Grand tour

::: columns
::: {.column width="45%"}
-   Tour is a high-dimensional data visualization technique based on rotation of high-to-low dimensional data projection.

-   Tour is used for EDA. It is used for detecting clusters, outliers, linear and non-linear dependencies that were not visible in the single variable plots.
:::

::: {.column width="5%"}
:::

::: {.column width="50%"}
```{r include=FALSE}
render_gif(flea[, 1:6], grand_tour(), 
           display_xy(axes="bottomleft", col = flea$species), 
           "flea.gif", frames=100, width=450, height=450)
```

![Grand tour](flea.gif){.r-stretch}
:::
:::

### Code

```{r echo=TRUE, eval=FALSE}
render_gif(flea[, 1:6], grand_tour(), 
           display_xy(axes="bottomleft", col = flea$species), 
           "flea.gif", frames=100, width=450, height=450)
```
:::

## Motivation of the project `r emo::ji("dizzy")` {.smaller .scrollable transition="slide"}

::: panel-tabset
### Plot

::: columns
::: {.column width="45%"}
-   The guided tour gives user an exploration power by combining projection pursuit with tour
-   Guided tour using LDA index

```{r include=FALSE}
render_gif(flea[, 1:6], guided_tour(lda_pp(flea$species)), 
           display_xy(col=flea$species, axes="bottomleft"), 
           "flea_guided.gif", 
           frames=50, width=450, height=450)
```
:::

::: {.column width="5%"}
:::

::: {.column width="50%"}
![Guided tour using LDA index on flea data](flea_guided.gif){.r-stretch}
:::
:::

### Code

```{r echo=TRUE, eval=FALSE}
render_gif(flea[, 1:6], guided_tour(lda_pp(flea$species)), 
           display_xy(col=flea$species, axes="bottomleft"), 
           "flea_guided.gif", 
           frames=50, width=450, height=450)
```
:::

## Motivation of the project `r emo::ji("dizzy")` {.smaller .scrollable transition="slide"}

-   Geodesic interpolation between planes.

-   The interpolated paths are visually invariant under changes of orientation.

![](tour_path.png){.r-stretch}

## Motivation of the project `r emo::ji("dizzy")` {.smaller .scrollable transition="slide"}

::: panel-tabset
### Plot

::: columns
::: {.column width="35%"}
-   However, in some cases of projection pursuit index the orientation of frames does matter.
-   One example is splines2D index.
-   This was the motivation of this work.
:::

::: {.column width="5%"}
:::

::: {.column width="60%"}
```{r}
data("sine_curve")

# Test out calculations
mat <- sine_curve[,5:6]
colnames(mat) <- c("x", "y")
mat_idx <- round(tourr::splines2d()(mat), 2)
mat_rot <- data.frame(x = cos(pi/6) * mat$x +
                          sin(pi/6) * mat$y,
                      y = -sin(pi/6) * mat$x+
                           cos(pi/6) * mat$y)
mat_rot_idx <- round(tourr::splines2d()(mat_rot), 2)

# Try a different way to show this
mat <- mat %>%
  mutate(type = "sine")
mat_rot <- mat_rot %>%
  mutate(type = "rotated")
mat_all <- bind_rows(mat, mat_rot)
mat_all <- mat_all %>%
  mutate(type = factor(type, levels=c("sine", "rotated")))
mat_all_label <- data.frame(x=c(0, 0.5),
                            y=c(0.75, -0.25),
     type=factor(c("sine", "rotated"), levels=c("sine", "rotated")),
     label=c(paste0("spl=",mat_idx),
             paste0("spl=",mat_rot_idx)))

ggplot(mat_all, aes(x=x, y=y, colour=type)) +
  geom_point() +
  xlab("") + ylab("") +
  scale_colour_manual("", values=c("black", "orange")) +
  geom_text(data=mat_all_label, aes(x=x, y=y, label=label, colour=type, size=20)) +
  theme(aspect.ratio=1, panel.background = element_rect(fill='white', colour='black'))
```
:::
:::

### Code

```{r eval=FALSE, echo=TRUE}
data("sine_curve")

# Test out calculations
mat <- sine_curve[,5:6]
colnames(mat) <- c("x", "y")
mat_idx <- round(tourr::splines2d()(mat), 2)
mat_rot <- data.frame(x = cos(pi/6) * mat$x +
                          sin(pi/6) * mat$y,
                      y = -sin(pi/6) * mat$x+
                           cos(pi/6) * mat$y)
mat_rot_idx <- round(tourr::splines2d()(mat_rot), 2)

# Try a different way to show this
mat <- mat %>%
  mutate(type = "sine")
mat_rot <- mat_rot %>%
  mutate(type = "rotated")
mat_all <- bind_rows(mat, mat_rot)
mat_all <- mat_all %>%
  mutate(type = factor(type, levels=c("sine", "rotated")))
mat_all_label <- data.frame(x=c(0, 0.5),
                            y=c(0.75, -0.25),
     type=factor(c("sine", "rotated"), levels=c("sine", "rotated")),
     label=c(paste0("spl=",mat_idx),
             paste0("spl=",mat_rot_idx)))

ggplot(mat_all, aes(x=x, y=y, colour=type)) +
  geom_point() +
  xlab("") + ylab("") +
  scale_colour_manual("", values=c("black", "orange")) +
  geom_text(data=mat_all_label, aes(x=x, y=y, label=label, colour=type)) +
  theme(aspect.ratio=1) +
  theme_bw()
```

### Data

```{r}
sine_curve
```
:::

## Motivation of the project `r emo::ji("dizzy")` {.scrollable transition="slide"}

![](plane_to_plane.png){.absolute top="170" left="5" width="450" height="400"}

![](frame_to_frame.png){.absolute top="170" right="5" width="450" height="400"}

## Notations `r emo::ji("spiral_notepad")` {.smaller .scrollable transition="slide"}

| Notation     | Description                                                              |
|---------------|---------------------------------------------------------|
| $p$          | dimension of original data                                               |
| $d$          | dimension onto which the data is being projected                         |
| $F$          | frame $p\times d$ matrix with pairwise orthogonal columns of unit length |
| $F_a = F(a)$ | starting frame                                                           |
| $F_z = F(z)$ | target frame                                                             |
| $F(t)$       | paths of projections are given by continuous one-parameter families      |

## Givens rotation `r emo::ji("right_arrow_curving_left")` {.smaller .scrollable transition="slide"}

A rotation matrix that performs a rotation of angle $\theta$ in Euclidean space in xy plane.

$$ \begin{bmatrix}\cos \theta &-\sin \theta \\\sin \theta &\cos \theta \end{bmatrix} $$

-   If the rotation is in the plane of variables i and j, it is called **Givens rotation.**
-   Used for introducing zeros on a grand scale and used for computing the QR decomposition of matrix in linear algebra problems.
-   One advantage of Givens rotation that is useful for us is the ability to zero elements selectively.

## Givens transformation for QR decomposition `r emo::ji("gem_stone")` {.scrollable transition="slide"}

```{=tex}
\begin{bmatrix} cos \theta & -\sin\theta & 0 \\\sin\theta &cos \theta &0\\ 0&0 &1\end{bmatrix} \begin{bmatrix} a_{11} & a_{12} &a_{13} \\a_{21}  &a_{22} &a_{23}\\ a_{31}&a_{32} &a_{33}\end{bmatrix} = 
\begin{bmatrix} b_{11} & b_{12} &b_{13} \\0 &b_{22} &b_{23}\\ b_{31}&b_{32} &b_{33}\end{bmatrix}
```

## Frames `r emo::ji("framed_picture")` {.scrollable transition="slide"}

```{r}
#| echo: true
#| fig-width: 10
#| fig-height: 4.5
set.seed(2022)
base1 <- orthonormalise(tourr::basis_random(6, d=2))
base2 <- orthonormalise(tourr::basis_random(6, d=2))

base1
base2
```


## Givens path algorithm `r emo::ji("pencil")` {.smaller .scrollable transition="slide"}

::: columns
::: {.column width="47.5%"}
#### Step 1

Construct preprojection basis $B$ by orthonormalizing $F_z$ with regards to $F_a$ with Gram-Schmidt:

$$B = (F_a, F_{\star})$$

#### Step 2

Get the preprojected frames using the preprojection basis $B$. $$W_a = B^TF_a = E_d$$ and $$W_z = B^TF_z$$
:::

::: {.column width="2%"}
:::

::: {.column width="50%"}
#### Step 1

```{r}
preprojection <- function(Fa, Fz) {
  # check both are matrices are both correct size
  stopifnot("Your inputs do not have the same number of columns!" = ncol(Fa) == ncol(Fz))
  stopifnot("Your inputs do not have the same number of row!" = nrow(Fa) == nrow(Fz))

  # check each is orthonormal
  stopifnot("The current frame must be orthonormal!" = tourr::is_orthonormal(Fa))
  stopifnot("The target frame must be orthonormal!" = tourr::is_orthonormal(Fz))

  Fz_star <- tourr::orthonormalise_by(Fz, Fa)
  B <- cbind(Fa, Fz_star)
  return(B)
}

set.seed(2022)
base1 <- orthonormalise(tourr::basis_random(6, d=2))
base2 <- orthonormalise(tourr::basis_random(6, d=2))

b <- preprojection(base1, base2) 

b  %>% round(3)
```

#### Step 2

```{r}
construct_preframe <- function(Fr, B) {
  W <- t(B) %*% Fr
  return(W)
}

construct_preframe(base1, b) %>% round(3)
construct_preframe(base2, b)  %>% round(3)
```
:::
:::

## Givens path algorithm `r emo::ji("pencil")` {.smaller .scrollable transition="slide"}

::: columns
::: {.column width="38%"}
#### Step 3

We can construct a sequence of Givens rotations that maps $W_z$ to $W_a$:

$$ W_a = R_m(\theta_m) ... R_2(\theta_2)R_1(\theta_1)W_z$$

At each rotation, the angle $\theta_i$ that zero out the second coordinate of a plane is calculated.

When $d = 2$, there are 5 rotations involved with 5 different angles that makes each elements 0.
:::

::: {.column width="2%"}
:::

::: {.column width="60%"}
#### Step 3

The first rotation angle $\theta_1$ is an angle between $(1, 0)$ and $(a_{11}, a_{21})$. This rotation matrix would make element $a_{21}$ zero:

$$R_1(\theta_1) = G(1, 2, \theta_1) = \begin{bmatrix} cos\theta_1 & -sin\theta_1 & 0 & 0 \\sin\theta_1  &cos\theta_1 & 0 &0 \\ 0&0&1&0 \\0&0&0&1\end{bmatrix}$$
:::
:::

## Givens path algorithm `r emo::ji("pencil")` {.smaller .scrollable transition="slide"}

#### Step 4

The inverse mapping is obtained by reversing the sequence of rotations with the negative of the angles, we starts from the starting basis and end at the target basis.

$$R(\theta) = R_1(-\theta_1) ... R_m(-\theta_m), \    W_z = R(\theta)W_a$$ This step should include the time parameter, $t$, so it shows the interpolation process rendered in the movie-like sequence.

#### Step 5

Finally, we reconstruct our original frame using $B$. This reconstruction is done at each step of interpolation so we have interpolated path as result.

$$F_t = B * W_t$$

## Implementation in R `r emo::ji("wrench")` {.scrollable transition="slide"}

```{r eval=FALSE, echo=TRUE}
preprojection <- function(Fa, Fz) {
  # check both are matrices are both correct size
  stopifnot("Your inputs do not have the same number of columns!" = ncol(Fa) == ncol(Fz))
  stopifnot("Your inputs do not have the same number of row!" = nrow(Fa) == nrow(Fz))

  Fz_star <- tourr::orthonormalise_by(Fz, Fa)
  B <- cbind(Fa, Fz_star)
  return(B)
}

construct_preframe <- function(Fr, B) {
  W <- t(B) %*% Fr
  return(W)
}

givens_rotation <- function(Wa, angles, stepfraction) {
  w_i = Wa
  for (col in ncol(Wa):1) {
    for (row in (nrow(Wa)-1):col){
      # rotating in reverse order
      index = paste0(col, row+1)
      theta = - as.numeric(angles[index])
      w_i = row_rot(w_i, col, row+1, theta*stepfraction)
    }
  }
  return(w_i)
}

construct_moving_frame <- function(Wt, B) {
  Ft = B %*% Wt
  return(Ft)
}

givens_full_path <- function(Fa, Fz, nsteps) {
  B <- preprojection(Fa, Fz)
  Wa <- construct_preframe(Fa, B)
  Wz <- construct_preframe(Fz, B)
  angles <- calculate_angles(Wa, Wz)
  path <- array(dim = c(nrow(B), ncol(Wa), nsteps))
  for (i in 1:nsteps) {
    stepfraction <- i/nsteps
    Wt = givens_rotation(Wa, angles, stepfraction)
    Ft = construct_moving_frame(Wt, B)
    path[,,i] <- Ft
  }
  return(path)
}
```

## Implementation illustration `r emo::ji("computer")` {.smaller .scrollable transition="slide"}

::: panel-tabset
### Plot

::: columns
::: {.column width="45%"}
-   1D interpolation path of 6D data on the surface of a sphere in 10 steps.

```{r include=FALSE}
set.seed(2022)
p <- 4
base1 <- tourr::basis_random(p, d=1)
base2 <- tourr::basis_random(p, d=1)

frames <- givens_full_path(base1, base2, nsteps = 10)

sp <- generate_space_view(p=p)

sp_path <- add_path(sp, frames) 

point1 <- as.data.frame(t(base1)) 
point1$type <- "point1"

point2 <- as.data.frame(t(base2))
point2$type <- "point2"

sp_path <- rbind(sp_path, point1, point2) 

sp_path <- rbind(sp_path, frames)

tourr::render_gif(sp_path[,1:p], 
                  tour_path = grand_tour(),
                  display = display_xy(axes="bottomleft", col=sp_path$type),
                  frames = 100,
                  "sphere.gif")
```
:::

::: {.column width="5%"}
:::

::: {.column width="50%"}
![](sphere.gif){.r-stretch}
:::
:::

### Code

```{r echo=TRUE, eval=FALSE}
set.seed(2022)
p <- 6
base1 <- tourr::basis_random(p, d=1)
base2 <- tourr::basis_random(p, d=1)

frames <- givens_full_path(base1, base2, nsteps = 10)

sp <- generate_space_view(p=p)

sp_path <- add_path(sp, frames) 

point1 <- as.data.frame(t(base1)) 
point1$type <- "point1"

point2 <- as.data.frame(t(base2))
point2$type <- "point2"

sp_path <- rbind(sp_path, point1, point2) 

sp_path <- rbind(sp_path, frames)

tourr::render_gif(sp_path[,1:p], 
                  tour_path = grand_tour(),
                  display = display_xy(axes="bottomleft", col=sp_path$type),
                  frames = 100,
                  "sphere.gif")
```
:::

## Data application `r emo::ji("check")` {.scrollable transition="slide"}

::: panel-tabset

### Motivation 

```{r}
data("sine_curve")

# Test out calculations
mat <- sine_curve[,5:6]
colnames(mat) <- c("x", "y")
mat_idx <- round(tourr::splines2d()(mat), 2)
mat_rot <- data.frame(x = cos(pi/6) * mat$x +
                          sin(pi/6) * mat$y,
                      y = -sin(pi/6) * mat$x+
                           cos(pi/6) * mat$y)
mat_rot_idx <- round(tourr::splines2d()(mat_rot), 2)

# Try a different way to show this
mat <- mat %>%
  mutate(type = "sine")
mat_rot <- mat_rot %>%
  mutate(type = "rotated")
mat_all <- bind_rows(mat, mat_rot)
mat_all <- mat_all %>%
  mutate(type = factor(type, levels=c("sine", "rotated")))
mat_all_label <- data.frame(x=c(0, 0.5),
                            y=c(0.75, -0.25),
     type=factor(c("sine", "rotated"), levels=c("sine", "rotated")),
     label=c(paste0("spl=",mat_idx),
             paste0("spl=",mat_rot_idx)))

ggplot(mat_all, aes(x=x, y=y, colour=type)) +
  geom_point() +
  xlab("") + ylab("") +
  scale_colour_manual("", values=c("black", "orange")) +
  geom_text(data=mat_all_label, aes(x=x, y=y, label=label, colour=type, size=20)) +
  theme(aspect.ratio=1, panel.background = element_rect(fill='white', colour='black'))
```

### Plot

![Using Givens path for optimizing Splines index](sine_anim.gif){.r-stretch}

### Code

```{r eval=FALSE, echo=TRUE}
# Generate a sample interpolation
set.seed(5543)
base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
base2 <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1), ncol=2, byrow=T)
sine_path <- givens_full_path(base1, base2, nsteps=100)
sine_all <- NULL
sine_proj <- NULL
for (i in 1:dim(sine_path)[3]) {
  d <- as.matrix(sine_curve) %*% as.matrix(sine_path[,,i])
  d <- data.frame(d)
  d$idx <- round(tourr::splines2d()(d), 2)
  d$frame <- i
  sine_all <- bind_rows(sine_all, d)
  prj <- as.data.frame(sine_path[,,i])
  prj$frame <- i
  prj$names <- colnames(sine_curve)
  sine_proj <- bind_rows(sine_proj, prj)
}
sine_label <- sine_all %>%
  mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
sine_proj <- sine_proj %>%
  mutate(cx = 0, cy = 0)
# With gganimate
library(gganimate)

sine_anim <- ggplot() +
  geom_segment(data=sine_proj, aes(x=V1, y=V2,
                                   xend=cx, yend=cy,
                                   group=frame),
               colour="grey60") +
  geom_text(data=sine_proj, aes(x=V1, y=V2,
                                label=names,
                                group=frame),
               colour="grey60") +
  geom_point(data=sine_label, aes(x=X1, y=X2)) +
  geom_text(data=sine_label, aes(x=labelX, y=labelY,
                label=label_idx), size=10) +
  xlab("") + ylab("") +
  transition_time(frame) +
  theme_void() +
  theme(aspect.ratio=1,
        plot.background = element_rect(fill=NULL, colour = "black"))

animate(sine_anim, fps=8, renderer = gifski_renderer(loop = FALSE), width=400, height=400)
anim_save("inst/sine_anim.gif")
```

:::

## Next steps `r emo::ji("soon")` {.scrollable transition="slide"}

-   Integrate with tour package
-   Produce data application examples
-   Produce hexsticker for the package
-   Produce RJournal article

## Summary `r emo::ji("raised_fist")` {.scrollable transition="slide"}

::: nonincremental
-   Alternative tour interpolation path
-   Used for detection of non-linear associations
:::

The woylier package repo is [here](https://github.com/numbats/woylier).

## References `r emo::ji("page_facing_up")` {.smaller .scrollable transition="slide"}

-   D. Asimov. The grand tour: A tool for viewing multidimensional data.
-   A. Buja, D. Cook, D. Asimov and C. Hurley. [Computational methods for high-dimensional rotations in data visualization.](10.1016/s0169-7161(04)24014-7)
-   U. Laa and D. Cook. [Using tours to visually investigate properties of new projection pursuit indexes with application to problems in physics.](https://doi.org/10.1007/s00180-020-00954-8)
-   B. Schloerke. [Geozoo: Zoo of geometric objects.](https://CRAN.R-project.org/package=geozoo)
-   H. Wickham, D. Cook, H. Hofmann and A. Buja. [tourr: An R package for exploring multivariate data with projections.](https://doi.org/10.18637/jss.v040.i02)

## Acknowledgements `r emo::ji("raising_hands")` {.scrollable transition="slide"}

Slides produced using [quarto](https://quarto.org).

Slides available in the [Github repo](https://github.com/numbats/woylier).

Thank you for listening `r emo::ji("smile")`
