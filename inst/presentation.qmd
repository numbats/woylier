---
title: "Woylier"
subtitle: "Alternative tour frame interpolation method"
author: "Zoljargal Batsaikhan<br>Supervised by Professor Di Cook and Ursula Laa<br>October 17, 2022"
format: 
  revealjs:
    revealjs: 
    slide-number: true
    chalkboard: 
      buttons: true
    css: styles.css
    footer: <https://numbats.github.io/woylier/>
editor: visual
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tourr)
library(tidyverse)
library(woylier)
library(geozoo)
library(ggplot2)
library(patchwork)
```

## Woylier

- Building an R package 
- Supervisor: Di Cook

## Outline

-   Motivation of the project
-   Notations
-   Givens transformation
-   Givens interpolation path algorithm
-   Implementation
-   How to use the package
-   Data application
-   Conclusion
-   Acknowledgements and references

## Motivation of the project 

- tour

```{r}
animate(flea[, 1:6], tour_path = grand_tour(), display = display_xy())
```

- guided tour

```{r}
animate_xy(flea[, 1:6], guided_tour(lda_pp(flea$species)), sphere = TRUE, col = flea$species)
```


## Motivation of the project 

![](tour_path.png){.r-stretch}

## Motivation of the project {.smaller .scrollable transition="slide"}

::: panel-tabset

### Plot

```{r}
data("sine_curve")

# Test out calculations
mat <- sine_curve[,5:6]
colnames(mat) <- c("x", "y")
mat_idx <- round(tourr::splines2d()(mat), 2)
mat_rot <- data.frame(x = cos(pi/6) * mat$x +
                          sin(pi/6) * mat$y,
                      y = -sin(pi/6) * mat$x+
                           cos(pi/6) * mat$y)
mat_rot_idx <- round(tourr::splines2d()(mat_rot), 2)

# Try a different way to show this
mat <- mat %>%
  mutate(type = "sine")
mat_rot <- mat_rot %>%
  mutate(type = "rotated")
mat_all <- bind_rows(mat, mat_rot)
mat_all <- mat_all %>%
  mutate(type = factor(type, levels=c("sine", "rotated")))
mat_all_label <- data.frame(x=c(0, 0.5),
                            y=c(0.75, -0.25),
     type=factor(c("sine", "rotated"), levels=c("sine", "rotated")),
     label=c(paste0("spl=",mat_idx),
             paste0("spl=",mat_rot_idx)))

ggplot(mat_all, aes(x=x, y=y, colour=type)) +
  geom_point() +
  xlab("") + ylab("") +
  scale_colour_manual("", values=c("black", "orange")) +
  geom_text(data=mat_all_label, aes(x=x, y=y, label=label, colour=type, size=20)) +
  theme(aspect.ratio=1, panel.background = element_rect(fill='white', colour='black'))
```

### Code

```{r eval=FALSE, echo=TRUE}
data("sine_curve")

# Test out calculations
mat <- sine_curve[,5:6]
colnames(mat) <- c("x", "y")
mat_idx <- round(tourr::splines2d()(mat), 2)
mat_rot <- data.frame(x = cos(pi/6) * mat$x +
                          sin(pi/6) * mat$y,
                      y = -sin(pi/6) * mat$x+
                           cos(pi/6) * mat$y)
mat_rot_idx <- round(tourr::splines2d()(mat_rot), 2)

# Try a different way to show this
mat <- mat %>%
  mutate(type = "sine")
mat_rot <- mat_rot %>%
  mutate(type = "rotated")
mat_all <- bind_rows(mat, mat_rot)
mat_all <- mat_all %>%
  mutate(type = factor(type, levels=c("sine", "rotated")))
mat_all_label <- data.frame(x=c(0, 0.5),
                            y=c(0.75, -0.25),
     type=factor(c("sine", "rotated"), levels=c("sine", "rotated")),
     label=c(paste0("spl=",mat_idx),
             paste0("spl=",mat_rot_idx)))

ggplot(mat_all, aes(x=x, y=y, colour=type)) +
  geom_point() +
  xlab("") + ylab("") +
  scale_colour_manual("", values=c("black", "orange")) +
  geom_text(data=mat_all_label, aes(x=x, y=y, label=label, colour=type)) +
  theme(aspect.ratio=1) +
  theme_bw()
```

### Data

```{r}
sine_curve
```
:::

## Motivation of the project

![](plane_to_plane.png){.absolute top="170" left="5" width="450" height="400"}

![](frame_to_frame.png){.absolute top="170" right="5" width="450" height="400"}

## Notations

| Notation | Description                                                            |
|------------|------------------------------------------------------------------------|
| $p$     | dimension of original data                            |
| $d$    | dimension onto which the data is being projected                 |
| $F$   |  frame $p\times d$ matrix with pairwise orthogonal columns of unit length               |
|  $F_a = F(a)$ | starting frame                                             |
|  $F_z = F(z)$ | target frame                                             |
| $F(t)$   | paths of projections are given by continuous one-parameter families |

## Givens rotation {.smaller}

A rotation matrix that performs a rotation of angle $\theta$ in Euclidean space in xy plane. 

$$ \begin{bmatrix}\cos \theta &-\sin \theta \\\sin \theta &\cos \theta \end{bmatrix} $$

- If the rotation is in the plane of variables i and j, it is called **Givens rotation.** 
- Used for introducing zeros on a grand scale and used for computing the QR decomposition of matrix in linear algebra problems. 
- One advantage of Givens rotation that is useful for us is the ability to zero elements selectively. 

## Givens transformation

\begin{bmatrix} b_{11} & b_{12} &b_{13} \\b_{21}  &b_{22} &b_{23}\\ 0&b_{32} &b_{33}\end{bmatrix} =\begin{bmatrix} cos \theta & -\sin\theta & 0 \\\sin\theta &cos \theta &0\\ 0&0 &1\end{bmatrix} \begin{bmatrix} a_{11} & a_{12} &a_{13} \\a_{21}  &a_{22} &a_{23}\\ a_{31}&a_{32} &a_{33}\end{bmatrix}


## Givens interpolation path algorithm {.smaller}

::: columns
::: {.column width="47.5%"}
#### Step 1

Construct preprojection basis $B$ by orthonormalizing $F_z$ with regards tp $F_a$ with Gram-Schmidt:

$$B = (F_a, F_{\star})$$

#### Step 2

Get the preprojected frames using the preprojection basis $B$.
$$W_a = B^TF_a = E_d$$ and $$W_z = B^TF_z$$

:::

::: {.column width="2%"}
:::

::: {.column width="50%"}
#### Step 1
```{r}
preprojection <- function(Fa, Fz) {
  # check both are matrices are both correct size
  stopifnot("Your inputs do not have the same number of columns!" = ncol(Fa) == ncol(Fz))
  stopifnot("Your inputs do not have the same number of row!" = nrow(Fa) == nrow(Fz))

  # check each is orthonormal
  stopifnot("The current frame must be orthonormal!" = tourr::is_orthonormal(Fa))
  stopifnot("The target frame must be orthonormal!" = tourr::is_orthonormal(Fz))

  Fz_star <- tourr::orthonormalise_by(Fz, Fa)
  B <- cbind(Fa, Fz_star)
  return(B)
}

set.seed(2022)
base1 <- orthonormalise(tourr::basis_random(6, d=2))
base2 <- orthonormalise(tourr::basis_random(6, d=2))

b <- preprojection(base1, base2) 

b  %>% round(3)
```

#### Step 2
```{r}
construct_preframe <- function(Fr, B) {
  W <- t(B) %*% Fr
  return(W)
}

construct_preframe(base1, b) %>% round(3)
construct_preframe(base2, b)  %>% round(3)
```
:::
:::


## Givens interpolation path algorithm {.smaller}

::: columns
::: {.column width="38%"}
#### Step 3

We can construct a sequence of Givens rotations that maps $W_z$ to $W_a$:

$$ W_a = R_m(\theta_m) ... R_2(\theta_2)R_1(\theta_1)W_z$$ 

At each rotation, the angle $\theta_i$ that zero out the second coordinate of a plane is calculated.

When $d = 2$, there are 5 rotations involved with 5 different angles that makes each elements 0.


:::

::: {.column width="2%"}
:::

::: {.column width="60%"}
#### Step 3
The first rotation angle $\theta_1$ is an angle between $(1, 0)$ and $(a_{11}, a_{21})$. This rotation matrix would make element $a_{21}$ zero:

$$R_1(\theta_1) = G(1, 2, \theta_1) = \begin{bmatrix} cos\theta_1 & -sin\theta_1 & 0 & 0 \\sin\theta_1  &cos\theta_1 & 0 &0 \\ 0&0&1&0 \\0&0&0&1\end{bmatrix}$$

:::
:::

## Givens interpolation path algorithm {.smaller}

#### Step 4

The inverse mapping is obtained by reversing the sequence of rotations with the negative of the angles, we starts from the starting basis and end at the target basis. 

$$R(\theta) = R_1(-\theta_1) ... R_m(-\theta_m), \    W_z = R(\theta)W_a$$
This step should include the time parameter, $t$, so it shows the interpolation process rendered in the movie-like sequence.

#### Step 5

Finally, we reconstruct our original frame using $B$. This reconstruction is done at each step of interpolation so we have interpolated path as result.

$$F_t = B * W_t$$

## Implementation {auto-animate="true"}

::: panel-tabset

### Plot

```{r}
set.seed(2022)
p <- 4
base1 <- tourr::basis_random(p, d=1)
base2 <- tourr::basis_random(p, d=1)
base3 <- tourr::basis_random(p, d=1)

frames <- givens_full_path(base1, base2, nsteps = 10)

sp <- generate_space_view(p=p)

sp_path <- add_path(sp, frames) 

point1 <- as.data.frame(t(base1)) 
point1$type <- "point1"

point2 <- as.data.frame(t(base2))
point2$type <- "point2"

sp_path <- rbind(sp_path, point1, point2) 

frames <- givens_full_path(base2, base3, nsteps = 10)
frames <- as.data.frame(t(apply(frames, 3, c)))
frames$type <- "path"
sp_path <- rbind(sp_path, frames)

point3 <- as.data.frame(t(base3))
point3$type <- "point3"

sp_path <- rbind(sp_path, point3) 
tourr::animate_xy(sp_path[,1:p], col=sp_path$type, 
                  axes="bottomleft")
```

### Code

```{r eval=FALSE, echo=TRUE}
set.seed(2022)
p <- 4
base1 <- tourr::basis_random(p, d=1)
base2 <- tourr::basis_random(p, d=1)
base3 <- tourr::basis_random(p, d=1)

frames <- givens_full_path(base1, base2, nsteps = 10)

sp <- generate_space_view(p=p)

sp_path <- add_path(sp, frames) 

point1 <- as.data.frame(t(base1)) 
point1$type <- "point1"

point2 <- as.data.frame(t(base2))
point2$type <- "point2"

sp_path <- rbind(sp_path, point1, point2) 

frames <- givens_full_path(base2, base3, nsteps = 10)
frames <- as.data.frame(t(apply(frames, 3, c)))
frames$type <- "path"
sp_path <- rbind(sp_path, frames)

point3 <- as.data.frame(t(base3))
point3$type <- "point3"

sp_path <- rbind(sp_path, point3) 
tourr::animate_xy(sp_path[,1:p], col=sp_path$type, 
                  axes="bottomleft")
```

:::


## Implementation {auto-animate="true"}

::: panel-tabset

### Plot

```{r}
set.seed(2022)
p <- 3
base1 <- tourr::basis_random(p, d=2)
base2 <- tourr::basis_random(p, d=2)

frames_2d <- givens_full_path(base1, base2, 10)
n <- 1000
d <- 2

proj_2d <- map(1:n, ~basis_random(n = p,  d=d)) %>%
  purrr::flatten_dbl() %>% 
  matrix(ncol = p*2, byrow = TRUE) %>%
  as_tibble()
path_2d <- t(apply(frames_2d, 3, c)) %>% 
  as.data.frame()

proj_2d <- proj_2d %>% 
  mutate(type="torus")
path_2d <- path_2d %>% 
  mutate(type="path")

proj_path <- bind_rows(proj_2d, path_2d)

tourr::animate_xy(proj_path[,1:6], 
                  col=proj_path$type, 
                  axes="bottomleft")
```

### Code

```{r eval=FALSE, echo=TRUE}
set.seed(2022)
p <- 3
base1 <- tourr::basis_random(p, d=2)
base2 <- tourr::basis_random(p, d=2)

frames_2d <- givens_full_path(base1, base2, 10)
n <- 1000
d <- 2

proj_2d <- map(1:n, ~basis_random(n = p,  d=d)) %>%
  purrr::flatten_dbl() %>% 
  matrix(ncol = p*2, byrow = TRUE) %>%
  as_tibble()
path_2d <- t(apply(frames_2d, 3, c)) %>% 
  as.data.frame()

proj_2d <- proj_2d %>% 
  mutate(type="torus")
path_2d <- path_2d %>% 
  mutate(type="path")

proj_path <- bind_rows(proj_2d, path_2d)

tourr::animate_xy(proj_path[,1:6], 
                  col=proj_path$type, 
                  axes="bottomleft")
```

:::

## Data application

- Code for the sine 

- the animation of the givens path for the splines example.

## Next steps

- Integrate with tour package
- Produce RJournal article

## Acknowledgements and references

- References

## Any questions?
